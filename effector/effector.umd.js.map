{"version":3,"file":"effector.umd.js","sources":["../../src/effector/is.ts","../../src/effector/region.ts","../../src/effector/createNode.ts","../../src/effector/collection.ts","../../src/effector/kernel.ts","../../src/effector/naming.ts","../../src/effector/template.ts","../../src/effector/createUnit.ts","../../src/effector/combine.ts","../../src/effector/defer.ts","../../src/effector/createEffect.ts","../../src/effector/merge.ts","../../src/effector/sample.ts","../../src/effector/fork/util.ts","../../src/effector/observable.ts","../../src/effector/tag.ts","../../src/effector/validate.ts","../../src/effector/throw.ts","../../src/effector/id.ts","../../src/effector/bind.ts","../../src/effector/step.ts","../../src/effector/stateRef.ts","../../src/effector/caller.ts","../../src/effector/getter.ts","../../src/effector/own.ts","../../src/effector/config.ts","../../src/effector/clearNode.ts","../../src/effector/subscription.ts","../../src/effector/forward.ts","../../src/effector/watch.ts","../../src/effector/createDomain.ts","../../src/effector/split.ts","../../src/effector/fork/allSettled.ts","../../src/effector/attach.ts","../../src/effector/createApi.ts","../../src/effector/fork/fork.ts","../../src/effector/fromObservable.ts","../../src/effector/guard.ts","../../src/effector/fork/hydrate.ts","../../src/effector/restore.ts","../../src/effector/fork/scopeBind.ts","../../src/effector/fork/serialize.ts"],"sourcesContent":["//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect first argument be an object') // or function\n}\n\nfunction assertNodeSetItem(value: any, method: string, valueName: string, reason: string) {\n  if ((!isObject(value) && !isFunction(value)) || (!('family' in value) && !('graphite' in value))) {\n    throwError(`${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`)\n  }\n}\nexport function assertNodeSet(value: any, method: string, valueName: string) {\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i]\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, '')\n    }\n  } else {\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n","import {getValue, getGraph, getParent, getMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport type {Template} from '../forest/index.h'\nimport {OPEN_O} from './tag'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: any\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}${OPEN_O}${sid}`\n  return sid\n}\n\nexport function withRegion(unit: any, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: getMeta(unit, 'template') || readTemplate(),\n    sidRoot: getMeta(unit, 'sidRoot') || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {\n      sidRoot: readSidRoot(sid),\n      name,\n      loc,\n      method,\n    },\n  })\n  return withRegion(sidNode, fn)\n}\n","import {Node, NodeUnit, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK, STORE} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\n\nconst arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n  }\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export function forIn<T>(\n  obj: Record<string, T>,\n  cb: (value: T, key: string) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = (list: any[], item: any) => list.includes(item)\n\nexport const removeItem = (list: any[], item: any) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Cmd, Node, NodeUnit, StateRef} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getMeta, getParent, getValue} from './getter'\nimport {\n  STORE,\n  EFFECT,\n  SAMPLER,\n  STACK,\n  BARRIER,\n  VALUE,\n  FILTER,\n  REG_A,\n  MAP,\n} from './tag'\nimport type {Scope} from './unit.h'\nimport {forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\nexport type Stack = {\n  value: any\n  a: any\n  b: any\n  parent: Stack | null\n  node: Node\n  page: Leaf | null\n  forkPage?: Scope | null | void\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  const isSameType = a.v.type === b.v.type\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (isSameType && a.v.id > b.v.id) ||\n    /** if first node is \"sampler\" and second node is \"barrier\" */\n    (!isSameType && a.v.type === SAMPLER)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 5) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  queue.push({first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 5; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * second bucket is for \"barrier\" PriorityType (used in combine)\n       * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 2 || i === 3) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  forkPage?: Scope | null | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      forkPage,\n    },\n    type,\n  )\nconst pushHeap = (\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number = 0,\n) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: null,\n    r: null,\n  }\n  /**\n   * second bucket is for \"barrier\" PriorityType (used in combine)\n   * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 2 || priority === 3) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case BARRIER:\n      return 2\n    case SAMPLER:\n      return 3\n    case EFFECT:\n      return 4\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  node: Node | null,\n  ref: StateRef,\n  isGetState?: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: Leaf | void | null\n  forkPage?: Scope | void\n  stack?: Stack | void\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {isRoot, currentPage, forkPage, isWatch}\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      switch (step.type) {\n        case BARRIER: {\n          const {priority, barrierID} = step.data\n          const id = page ? `${page.fullID}_${barrierID}` : barrierID\n          if (stepn !== idx || type !== priority) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n            continue kernelLoop\n          }\n          barriers.delete(id)\n          break\n        }\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, node, data.store.id).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, forkPage, node, data.target).current = value\n              break\n          }\n          break\n        }\n        case 'check': {\n          skip =\n            getValue(stack) ===\n            (step.data.type === 'defined'\n              ? undefined\n              : readRef(getPageRef(page, forkPage, node, step.data.store)))\n          break\n        }\n        case FILTER:\n          /**\n           * handled edge case: if step.fn will throw,\n           * tryRun will return null\n           * thereby forcing that branch to stop\n           */\n          skip = !tryRun(local, step.data, stack)\n          break\n        case 'run':\n          /** exec 'compute' step when stepn === idx */\n          if (stepn !== idx || type !== EFFECT) {\n            pushHeap(stepn, stack, EFFECT)\n            continue kernelLoop\n          }\n        case 'compute':\n          isWatch = getMeta(node, 'op') === 'watch'\n          stack.value = tryRun(local, step.data, stack)\n          isWatch = lastStartedState.isWatch\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      for (let stepn = 0; stepn < node.next.length; stepn++) {\n        pushFirstHeapItem(\n          'child',\n          page,\n          node.next[stepn],\n          stack,\n          getValue(stack),\n          getForkPage(stack),\n        )\n      }\n      const forkPage: Scope | null = getForkPage(stack)\n      if (forkPage) {\n        if (getMeta(node, 'needFxCounter'))\n          pushFirstHeapItem('child', page, forkPage.fxCount, stack, 0, forkPage)\n        if (getMeta(node, 'storeChange'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            0,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          for (let stepn = 0; stepn < additionalLinks.length; stepn++) {\n            pushFirstHeapItem(\n              'child',\n              page,\n              additionalLinks[stepn],\n              stack,\n              getValue(stack),\n              forkPage,\n            )\n          }\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nexport const initRefInScope = (\n  scope: {\n    reg: Record<string, StateRef>\n    sidValuesMap: Record<string, any>\n    sidIdMap: Record<string, string>\n  },\n  sourceRef: StateRef,\n  isGetState?: boolean,\n) => {\n  const refsMap = scope.reg\n  if (refsMap[sourceRef.id]) return\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.current,\n  }\n  if (sourceRef.sid) scope.sidIdMap[sourceRef.sid] = sourceRef.id\n  if (sourceRef.sid && sourceRef.sid in scope.sidValuesMap) {\n    ref.current = scope.sidValuesMap[sourceRef.sid]\n  } else {\n    const noInit = !isGetState && sourceRef.noInit\n    if (!noInit && sourceRef.before) {\n      let isFresh = false\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState)\n              const value = from && refsMap[from.id].current\n              ref.current = cmd.fn ? cmd.fn(value) : value\n            }\n            break\n          }\n          case 'field': {\n            initRefInScope(scope, cmd.from, isGetState)\n            const from = refsMap[cmd.from.id]\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            ref.current[cmd.field] = refsMap[from.id].current\n            break\n          }\n          case 'closure':\n            break\n        }\n      })\n    }\n  }\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (\n  local: Local,\n  {fn}: Extract<Cmd, {data: {fn: Function}}>['data'],\n  stack: Stack,\n) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import type {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\nimport {forIn} from './collection'\n\nconst getCompostite = (unit: any): CompositeName => unit.compositeName\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, (unit: any) => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit) ? getCompostite(unit).fullName : unit.toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompostite(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompostite(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn: any = template.handlers[method]\n    if (fn) return fn(template, ...args)\n  }\n}\n","import {observableSymbol} from './observable'\n\nimport {is, isObject, isFunction, assertObject, assertNodeSet} from './is'\nimport type {Store, Event} from './unit.h'\n\nimport {step} from './typedef'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {bind} from './bind'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n} from './kernel'\n\nimport {Subscriber, Config} from './index.h'\nimport {createName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getConfig,\n  getNestedConfig,\n  getStoreState,\n  getGraph,\n  getParent,\n} from './getter'\nimport {throwError} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, REG_A, OPEN_O} from './tag'\nimport {applyTemplate} from './template'\n\nconst normalizeConfig = (part: any, config: any) => {\n  if (isObject(part)) {\n    normalizeConfig(getConfig(part), config)\n    if (part.name != null) {\n      if (isObject(part.name)) normalizeConfig(part.name, config)\n      else if (isFunction(part.name)) config.handler = part.name\n      else config.name = part.name\n    }\n    if (part.loc) config.loc = part.loc\n    if (part.sid || part.sid === null) config.sid = part.sid\n    if (part.handler) config.handler = part.handler\n    if (part.updateFilter) config.updateFilter = part.updateFilter\n    if (getParent(part)) config.parent = getParent(part)\n    if ('strict' in part) config.strict = part.strict\n    if (part.named) config.named = part.named\n    normalizeConfig(getNestedConfig(part), config)\n  }\n  return config\n}\n\nexport const applyParentHook = (\n  source: any,\n  target: any,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nlet isStrict: boolean\nexport const initUnit = (\n  kind: any,\n  unit: any,\n  rawConfigA: any,\n  rawConfigB?: any,\n) => {\n  const config = normalizeConfig(\n    {\n      name: rawConfigB,\n      config: rawConfigA,\n    },\n    {},\n  )\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  let {parent = null, sid = null, strict = true, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n\n  const meta: Record<string, any> = {\n    unit: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => fn(unit)\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => {\n              if (observer.next) {\n                observer.next(upd)\n              }\n            },\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  isStrict = strict\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (event: any, op: string, fn: any, node: any) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent({name: `${event.shortName} → *`, [OPEN_O]: config})\n  createLinkNode(event, mapped, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n  return mapped\n}\n\nfunction callCreate(unit: any, template: any, payload: any, args: any[]): any {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) => {\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }\n  event.graphite = createNode({\n    meta: initUnit(EVENT, event, maybeConfig, nameOrConfig),\n    regional: true,\n  })\n  //eslint-disable-next-line no-unused-vars\n  event.create = (params: any, _: any) => {\n    launch({target: event, params, forkPage: forkPage!})\n    return params\n  }\n  event.watch = bind(watchUnit, event)\n  event.map = (fn: any) =>\n    deriveEvent(event, MAP, fn, [step.compute({fn: callStack})])\n  event.filter = (fn: any) =>\n    deriveEvent(event, FILTER, fn.fn ? fn : fn.fn, [\n      step.filter({fn: callStack}),\n    ])\n  event.filterMap = (fn: any) =>\n    deriveEvent(event, 'filterMap', fn, [\n      step.compute({fn: callStack}),\n      step.check.defined(),\n    ])\n  event.prepend = (fn: any) => {\n    const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n      parent: getParent(event),\n    })\n    applyTemplate('eventPrepend', getGraph(contramapped))\n    createLinkNode(contramapped, event, {\n      scope: {fn},\n      node: [step.compute({fn: callStack})],\n      meta: {op: 'prepend'},\n    })\n    applyParentHook(event, contramapped)\n    return contramapped\n  }\n  const template = readTemplate()\n  return event\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const oldState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  applyTemplate('storeBase', plainState, oldState)\n  const plainStateId = plainState.id\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState(state: any) {\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        forkPage: forkPage!,\n      })\n    },\n    reset(...units: any[]) {\n      for (const unit of units) store.on(unit, () => store.defaultState)\n      return store\n    },\n    on(nodeSet: any, fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      if (Array.isArray(nodeSet)) {\n        for (const event of nodeSet) {\n          onEvent(event, fn)\n        }\n      } else {\n        onEvent(nodeSet, fn)\n      }\n      return store\n    },\n    off(unit: any) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: any, firstState?: any) {\n      let config\n      if (isObject(fn)) {\n        config = fn\n        fn = fn.fn\n      }\n      if (firstState !== undefined) {\n        console.error(\n          'second argument of store.map is deprecated, use updateFilter instead',\n        )\n      }\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (storeState !== undefined) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName} → *`,\n        [OPEN_O]: config,\n        strict: false,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, false, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      if (!isFunction(fn)) throwError('second argument should be a function')\n      return eventOrFn.watch((payload: any) => fn(store.getState(), payload))\n    },\n  }\n  function onEvent(event: any, fn: Function) {\n    store.off(event)\n    getSubscribers(store).set(\n      event,\n      createSubscription(\n        updateStore(event, store, 'on', true, fn, updateFilter),\n      ),\n    )\n  }\n  const meta = initUnit(STORE, store, props)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState},\n    node: [\n      step.check.defined(),\n      step.check.changed({\n        store: oldState,\n      }),\n      updateFilter && step.mov({store: oldState, to: REG_A}),\n      updateFilter &&\n        step.filter({\n          fn: (update, _, {a}) => updateFilter(update, a),\n        }),\n      step.update({\n        store: plainState,\n      }),\n      step.update({\n        store: oldState,\n      }),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  if (meta.sid) {\n    meta.storeChange = true\n    plainState.sid = meta.sid\n  }\n  if (isStrict && defaultState === undefined)\n    throwError(\"current state can't be undefined, use null instead\")\n  own(store, [updates])\n  return store\n}\n\nconst updateStore = (\n  from: any,\n  store: Store<any>,\n  op: string,\n  stateFirst: boolean,\n  fn: Function,\n  updateFilter?: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const node = [\n    step.mov({store: storeRef, to: REG_A}),\n    step.compute({\n      fn: stateFirst ? callARegStack : callStackAReg,\n    }),\n    step.check.defined(),\n    step.check.changed({store: storeRef}),\n    updateFilter &&\n      step.filter({\n        fn: (update, _, {a}) => updateFilter(update, a),\n      }),\n    step.update({store: storeRef}),\n  ]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n}\n","import type {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {step} from './typedef'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {throwError} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport {callStack} from './caller'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  onConfigNesting(args[0], (injectedData, userConfig) => {\n    config = injectedData\n    args = userConfig\n  })\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | void\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = (list: any[]) => fn(...list)\n    }\n  }\n  if (!isObject(structStoreShape)) throwError('shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj: any,\n  config?: string,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => list.slice() : (obj: any) => ({...obj})\n  const defaultState: any = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: config ? config : unitObjectName(obj),\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const node = [\n    step.check.defined(),\n    step.mov({\n      store: rawShape,\n      to: REG_A,\n    }),\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {key}, {a}) => upd !== a[key],\n    }),\n    step.mov({\n      store: isFresh,\n      to: 'b',\n    }),\n    step.compute({\n      fn(upd, {clone, key, spread}, reg) {\n        if (spread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n      },\n    }),\n    step.mov({\n      from: REG_A,\n      target: rawShape,\n    }),\n    step.mov({\n      from: VALUE,\n      store: false,\n      target: isFresh,\n    }),\n    step.barrier({priority: BARRIER}),\n    step.mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n    }),\n    step.mov({store: rawShape}),\n    fn && step.compute({fn: callStack}),\n    step.check.changed({\n      store: storeStateRef,\n    }),\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, {\n      scope: {key, clone, fn, spread: needSpread},\n      node,\n      meta: {op: 'combine'},\n    })\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {\n      type: 'field',\n      field: key,\n      from: childRef,\n    })\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    store.defaultState = fn\n      ? (storeStateRef.current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n\nexport function createStoreObject(...args: any[]) {\n  console.error('createStoreObject is deprecated, use combine instead')\n  return combine(...args)\n}\n","export function createDefer(): {\n  rs: (value: any) => any\n  rj: (value: any) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value: any) => any\n    rj: (value: any) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import {step} from './typedef'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch, Stack} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {throwError} from './throw'\nimport {EFFECT} from './tag'\nimport type {Unit} from './index.h'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig?: any,\n) {\n  const instance: any = createEvent(nameOrConfig, maybeConfig)\n  let handler =\n    instance.defaultConfig.handler ||\n    (() => throwError(`no handler used in ${instance.getType()}`))\n  const node = getGraph(instance)\n  setMeta(node, 'unit', (instance.kind = EFFECT))\n  instance.use = (fn: Function) => {\n    if (!isFunction(fn)) throwError('.use argument should be a function')\n    handler = fn\n    return instance\n  }\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}: any) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}: any) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: any) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: any) => error,\n  }))\n\n  const effectRunner = createNode({\n    scope: {\n      getHandler: (instance.use.getCurrent = () => handler),\n      finally: anyway,\n      handlerId: getMeta(node, 'sid'),\n    },\n    node: [\n      step.run({\n        fn({params, req}, {finally: anyway, getHandler, handlerId}, stack) {\n          const onResolve = onSettled(params, req, true, anyway, stack)\n          const onReject = onSettled(params, req, false, anyway, stack)\n          let result\n          try {\n            let handler: (data: any) => any\n            if (getForkPage(stack)) {\n              const handler_ = getForkPage(stack).handlers[handlerId]\n              handler = handler_ ? handler_ : getHandler()\n            } else {\n              handler = getHandler()\n            }\n            result = handler(params)\n          } catch (err) {\n            return void onReject(err)\n          }\n          if (isObject(result) && isFunction(result.then)) {\n            result.then(onResolve, onReject)\n          } else {\n            onResolve(result)\n          }\n        },\n      }),\n    ],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n    },\n  })\n  node.scope.runner = effectRunner\n  node.seq.push(\n    step.compute({\n      fn(params, scope, stack) {\n        // empty stack means that this node was launched directly\n        if (!getParent(stack)) return params\n        return {\n          params,\n          req: {\n            rs(data: any) {},\n            rj(data: any) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn(upd, {runner}, stack) {\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          forkPage: getForkPage(stack),\n        })\n        return upd.params\n      },\n    }),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch({\n        target: instance,\n        params: payload,\n        forkPage,\n      })\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n  setMeta(anyway, 'needFxCounter', true)\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-ignore\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [\n    anyway,\n    done,\n    fail,\n    doneData,\n    failData,\n    pending,\n    inFlight,\n    effectRunner,\n  ])\n  return instance\n}\n\nexport const onSettled =\n  (\n    params: any,\n    req: {\n      rs(_: any): any\n      rj(_: any): any\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n  ) =>\n  (data: any) =>\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {\n              status: 'done',\n              params,\n              result: data,\n            }\n          : {\n              status: 'fail',\n              params,\n              error: data,\n            },\n        {\n          fn: ok ? req.rs : req.rj,\n          value: data,\n        },\n      ],\n      defer: true,\n      page: stack.page,\n      forkPage: getForkPage(stack),\n    })\n\nexport const sidechain = createNode({\n  node: [\n    step.run({\n      fn({fn, value}) {\n        fn(value)\n      },\n    }),\n  ],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {forward} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  events: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  const result = createEvent(config || unitObjectName(events, 'merge'))\n  assertNodeSet(events, 'merge', 'first argument')\n  forward({\n    from: events,\n    to: result,\n    meta: {op: 'merge'},\n  })\n  return result\n}\n","import {combine} from './combine'\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {own} from './own'\nimport {assertNodeSet, is, isObject} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {throwError} from './throw'\nimport {forEach} from './collection'\nimport {REG_A, SAMPLE, SAMPLER, STACK, STORE, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nfunction validateSampleConfig(config: any) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      if (config[field] == null) {\n        throwError(`sample: ${field} should be defined`)\n      }\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any): any {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let greedy\n  //config case\n  if (clock === undefined && isObject(source) && validateSampleConfig(source)) {\n    clock = source.clock\n    fn = source.fn\n    greedy = source.greedy\n    //optional target & name accepted only from config\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'sample', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) {\n    source = combine(source)\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  assertNodeSet(clock, 'sample', 'clock')\n  name = metadata || name || source.shortName\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid})\n    } else {\n      target = createEvent(name)\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    const sourceRef = getStoreState(source)\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {fn},\n        // scope: {fn, targetTemplate},\n        node: [\n          applyTemplate('sampleSourceLoader'),\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({\n            store: sourceRef,\n            to: fn ? REG_A : STACK,\n          }),\n          fn && step.compute({fn: callARegStack}),\n          applyTemplate('sampleSourceUpward', isUpward),\n        ],\n        meta: {op: SAMPLE, sample: STORE},\n      }),\n    ])\n    applyTemplate('sampleStoreSource', sourceRef)\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceState = createStateRef()\n    const clockState = createStateRef()\n    applyTemplate('sampleNonStoreSource', hasSource, sourceState, clockState)\n    createNode({\n      parent: source,\n      node: [\n        step.update({store: sourceState}),\n        step.mov({\n          from: VALUE,\n          store: true,\n          target: hasSource,\n        }),\n      ],\n      family: {\n        owners: [source, target, clock],\n        links: target,\n      },\n      meta: {op: SAMPLE, sample: 'source'},\n      regional: true,\n    })\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {\n          fn,\n          // targetTemplate,\n        },\n        node: [\n          applyTemplate('sampleSourceLoader'),\n          step.update({store: clockState}),\n          step.mov({store: hasSource}),\n          step.filter({fn: hasSource => hasSource}),\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({store: sourceState}),\n          step.mov({\n            store: clockState,\n            to: REG_A,\n          }),\n          fn && step.compute({fn: callStackAReg}),\n          applyTemplate('sampleSourceUpward', isUpward),\n        ],\n        meta: {op: SAMPLE, sample: 'clock'},\n      }),\n    ])\n  }\n  return target\n}\n","import {getForkPage, getGraph, getMeta, getParent} from '../getter'\nimport {is} from '../is'\nimport {throwError} from '../throw'\nimport {setForkPage, getPageRef, currentPage} from '../kernel'\nimport {createNode} from '../createNode'\nimport {step} from '../typedef'\nimport type {Domain, Scope, Store} from '../unit.h'\nimport type {Node, StateRef} from '../index.h'\nimport {forEach} from '../collection'\nimport {DOMAIN, SAMPLER, FORK_COUNTER, SCOPE} from '../tag'\n\nexport function normalizeValues(\n  values: Map<Store<any>, any> | Array<[any, any]> | Record<string, any>,\n  assertEach?: (key: any, value: any) => void,\n) {\n  if (Array.isArray(values)) values = new Map(values)\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    for (const [key, value] of values) {\n      if (!is.unit(key)) throwError('Map key should be a unit')\n      if (assertEach) assertEach(key, value)\n      result[key.sid!] = value\n    }\n    return result\n  }\n  return values\n}\n\n/**\n everything we need to clone graph section\n reachable from given unit\n */\nexport function cloneGraph(unit?: Domain): Scope {\n  const forkInFlightCounter = createNode({\n    scope: {\n      defers: [],\n      inFlight: 0,\n      fxID: 0,\n    },\n    node: [\n      step.compute({\n        fn(_, scope, stack) {\n          if (!getParent(stack)) {\n            scope.fxID += 1\n            return\n          }\n          if (getMeta(getParent(stack).node, 'named') === 'finally') {\n            scope.inFlight -= 1\n          } else {\n            scope.inFlight += 1\n            scope.fxID += 1\n          }\n        },\n      }),\n      step.barrier({priority: SAMPLER}),\n      step.run({\n        fn(_, scope) {\n          const {inFlight, defers, fxID} = scope\n          if (inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), (defer: any) => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n      }),\n    ],\n    meta: {unit: FORK_COUNTER},\n  })\n  const page = {} as Record<string, StateRef>\n  const storeChange = createNode({\n    node: [\n      step.compute({\n        fn(value, __, stack) {\n          const storeStack = getParent(stack)\n          if (storeStack && getParent(storeStack)) {\n            const storeNode = storeStack.node\n            if (\n              !getMeta(storeNode, 'isCombine') ||\n              getMeta(getParent(storeStack).node, 'op') !== 'combine'\n            ) {\n              const forkPage: Scope = getForkPage(stack)\n              const id = storeNode.scope.state.id\n              const sid = getMeta(storeNode, 'sid')\n              forkPage.sidIdMap[sid] = id\n              forkPage.sidValuesMap[sid] = value\n            }\n          }\n        },\n      }),\n    ],\n  })\n  const resultScope: Scope = {\n    cloneOf: unit,\n    reg: page,\n    sidValuesMap: {},\n    sidIdMap: {},\n    getState(store: any) {\n      if ('current' in store) {\n        return getPageRef(currentPage, resultScope, null, store).current\n      }\n      return stateGetter(getGraph(store), resultScope)\n    },\n    kind: SCOPE,\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, storeChange],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n    additionalLinks: {},\n    handlers: {},\n    fxCount: forkInFlightCounter,\n    storeChange,\n  }\n  return resultScope\n}\nfunction stateGetter(node: Node, scope: Scope) {\n  return getPageRef(currentPage, scope, node, node.scope.state, true).current\n}\n","export const observableSymbol: any =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const FORK_COUNTER = 'forkInFlightCounter'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\nexport const OPEN_O = `\\u0254`\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {Domain, Effect, Event, Scope, Store} from './unit.h'\n\nexport const unit = (obj: any) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: any) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value: any) => value is Store<unknown>\nexport const event = is(EVENT) as (value: any) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value: any,\n) => value is Effect<unknown, unknown, unknown>\nexport const domain = is(DOMAIN) as (value: any) => value is Domain\nexport const scope = is(SCOPE) as (value: any) => value is Scope\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","export const bind = (fn: Function, target: any) => fn.bind(null, target)\n","import {\n  StateRef,\n  Run,\n  Filter,\n  Compute,\n  Barrier,\n  CheckDefined,\n  CheckChanged,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {bind} from './bind'\nimport {BARRIER, FILTER, STACK, STORE} from './tag'\nimport {Stack} from './kernel'\n\nconst cmd = (\n  type: 'check' | 'compute' | 'filter' | 'mov' | 'barrier',\n  data: any,\n): any => ({\n  id: nextStepID(),\n  type,\n  data,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier = ({\n  priority = BARRIER,\n}: {\n  priority?: 'barrier' | 'sampler'\n}): Barrier =>\n  cmd(BARRIER, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: {\n  <T>(data: {from: 'value'; store: T; target: StateRef}): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n  }): MovValueToRegister<T>\n  (data: {from: 'a' | 'b' | 'stack'; target: StateRef}): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n  }): MovRegisterToStore\n  (data: {store: StateRef; target: StateRef}): MovStoreToStore\n  (data: {store: StateRef; to: 'stack' | 'a' | 'b'}): MovStoreToRegister\n  (data: {store: StateRef}): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n}) => cmd('mov', {from, store, to, target})\nexport const check = {\n  defined: (): CheckDefined => cmd('check', {type: 'defined'}),\n  changed: ({store}: {store: StateRef}): CheckChanged =>\n    cmd('check', {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => Compute = bind(cmd, 'compute')\nexport const filter: (data: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => Filter = bind(cmd, FILTER)\nexport const run: (data: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => Run = bind(cmd, 'run')\nexport const update = ({store}: {store: StateRef}) =>\n  mov({from: STACK, target: store})\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  ref.before!.push(op as any)\n}\n","import type {Stack} from './kernel'\n\nexport const callStackAReg = (stack: any, {fn}: any, {a}: Stack) => fn(stack, a)\nexport const callARegStack = (stack: any, {fn}: any, {a}: Stack) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: any, _: Stack) => fn(stack)\n","import type {Node, StateRef} from './index.h'\nimport {OPEN_O} from './tag'\n\nexport const getGraph = (graph: any): Node => graph.graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: any): StateRef => store.stateRef\nexport const getConfig = (opts: any) => opts.config\nexport const getNestedConfig = (opts: any) => opts[OPEN_O]\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: any) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any) => val.forkPage\nexport const getMeta = (unit: any, field: string) => getGraph(unit).meta[field]\nexport const setMeta = (unit: any, field: string, value: any) =>\n  (getGraph(unit).meta[field] = value)\n","import {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  for (let i = 0; i < links.length; i++) {\n    const link = getGraph(links[i])\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    getOwners(link).push(owner)\n    getLinks(owner).push(link)\n  }\n}\n","import {getConfig, getNestedConfig} from './getter'\nimport {assertObject} from './is'\n\nexport const onConfigNesting = (\n  rawConfig: any,\n  fn: (babelData: any, userConfig: any) => void,\n) => {\n  assertObject(rawConfig)\n  if (getNestedConfig(rawConfig)) {\n    fn(getConfig(rawConfig), getNestedConfig(rawConfig))\n  }\n}\n\nexport const processArgsToConfig = (args: any[]): [any[], any | void] => {\n  let metadata\n  onConfigNesting(args[0], (injected, config) => {\n    metadata = injected\n    args = config\n  })\n  return [args, metadata]\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers, getMeta} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-ignore\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !getMeta(targetNode, 'sample')) ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-ignore\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    //@ts-ignore\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = () => clearNode(node)\n  result.unsubscribe = result\n  return result\n}\n","import {onConfigNesting} from './config'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit,\n  child: NodeUnit | NodeUnit[],\n  {\n    node,\n    scope,\n    meta,\n  }: {\n    node?: Array<Cmd | false | void | null>\n    scope?: {[name: string]: any}\n    meta?: {[name: string]: any}\n  },\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope,\n    meta,\n    family: {\n      owners: [parent, child],\n      links: child,\n    },\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  let config\n  onConfigNesting(opts, (injectedData, userConfig) => {\n    config = injectedData\n    opts = userConfig\n  })\n  const {from, to, meta = {op: 'forward'}} = opts\n  assertNodeSet(from, 'forward', '\"from\"')\n  assertNodeSet(to, 'forward', '\"to\"')\n  if (config) meta.config = config\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta,\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {throwError} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  if (!isFunction(handler)) throwError('.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [step.run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {\n        owners: unit,\n      },\n      regional: true,\n    }),\n  )\n}\n","import {Store, Event, Effect, Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {forward} from './forward'\nimport {forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {step} from './typedef'\n\nconst createHook = (trigger: Event<any>, acc: Set<any>, node: any) => {\n  trigger.create = res => {\n    launch(trigger, res)\n    return res\n  }\n  getGraph(trigger).seq.push(\n    step.compute({\n      fn(upd, _, stack) {\n        stack.forkPage = null\n        return upd\n      },\n    }),\n  )\n  trigger.watch(data => {\n    own(node, [data])\n    acc.add(data)\n    if (!data.ownerSet) data.ownerSet = acc\n    if (!getParent(data)) data.parent = node\n  })\n  own(node, [trigger])\n  return (hook: (data: any) => any) => {\n    acc.forEach(hook)\n    return trigger.watch(hook)\n  }\n}\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const domains: Set<Domain> = new Set()\n  const stores: Set<Store<any>> = new Set()\n  const effects: Set<Effect<any, any, any>> = new Set()\n  const events: Set<Event<any>> = new Set()\n\n  const node = createNode({\n    family: {type: DOMAIN},\n    regional: true,\n  })\n\n  const result: any = {\n    history: {\n      domains,\n      stores,\n      effects,\n      events,\n    },\n    graphite: node,\n  }\n\n  node.meta = initUnit(DOMAIN, result, maybeConfig, nameOrConfig)\n  const [event, effect, store, domain] = [\n    'onEvent',\n    'onEffect',\n    'onStore',\n    'onDomain',\n  ].map(createNamedEvent)\n\n  result.hooks = {\n    event,\n    effect,\n    store,\n    domain,\n  }\n  result.onCreateEvent = createHook(event, events, result)\n  result.onCreateEffect = createHook(effect, effects, result)\n  result.onCreateStore = createHook(store, stores, result)\n  result.onCreateDomain = createHook(domain, domains, result)\n\n  result.createEvent = result.event = (nameOrConfig: any, config?: Config) =>\n    event(\n      createEvent(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createEffect = result.effect = (nameOrConfig: any, config?: Config) =>\n    effect(\n      createEffect(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createDomain = result.domain = (nameOrConfig: any, config?: Config) =>\n    createDomain({\n      name: nameOrConfig,\n      parent: result,\n      config,\n    })\n  result.createStore = result.store = (state: any, config?: Config) =>\n    store(\n      createStore(state, {\n        parent: result,\n        config,\n      }),\n    )\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from: NodeUnit, key) => {\n      forward({from, to: parent.hooks[key]})\n    })\n    parent.hooks.domain(result)\n  }\n  return result\n}\n","import {Event} from './unit.h'\nimport {NodeUnit, Cmd} from './index.h'\nimport {is, isFunction, isObject} from './is'\nimport {forIn, includes} from './collection'\nimport {addRefOp, createStateRef} from './stateRef'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {step} from './typedef'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {REG_A} from './tag'\nimport {throwError} from './throw'\nimport {createEvent} from './createUnit'\nimport {applyTemplate} from './template'\n\nconst launchCase = (\n  scopeTargets: Record<string, NodeUnit>,\n  field: string,\n  data: any,\n  stack: any,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]): any {\n  let targets: Record<string, Event<any> | NodeUnit>\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const knownCases = !match\n  if (knownCases) {\n    targets = source.cases\n    match = source.match\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  if (!targets!) targets = {}\n  if (!knownCases) {\n    if (!matchIsShape) throwError('match should be an object')\n    forIn(match, (_, key) => {\n      //@ts-ignore\n      targets[key] = createEvent(metadata)\n    })\n    targets.__ = createEvent(metadata)\n  }\n  const owners = new Set(\n    ([] as NodeUnit[]).concat(source, Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && step.barrier({priority: 'sampler'}),\n      matchIsUnit &&\n        step.mov({\n          store: getStoreState(match),\n          to: 'a',\n        }),\n      step.filter({\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const updaterSteps = [\n      step.mov({\n        store: lastValues,\n        to: REG_A,\n      }),\n      step.compute({\n        fn(upd, {key}, {a}) {\n          a[key] = upd\n        },\n      }),\n    ]\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn: any, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        units.push(key)\n        owners.add(storeOrFn)\n        const updater = createLinkNode(storeOrFn, [], {\n          node: updaterSteps,\n          scope: {key},\n        })\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          addRefOp(lastValues, {\n            type: 'field',\n            field: key,\n            from: storeRef,\n          })\n          applyTemplate('splitMatchStore', storeRef, updater)\n        }\n      }\n    })\n    if (needBarrier!) {\n      applyTemplate('splitBase', lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && step.barrier({priority: 'sampler'}),\n      needBarrier! &&\n        step.mov({\n          store: lastValues,\n          to: 'a',\n        }),\n      step.filter({\n        fn(data, scopeTargets, stack) {\n          for (let i = 0; i < caseNames.length; i++) {\n            const caseName = caseNames[i]\n            const caseValue = includes(units, caseName)\n              ? stack.a[caseName]\n              : match[caseName](data)\n            if (caseValue) {\n              launchCase(scopeTargets, caseName, data, stack)\n              return\n            }\n          }\n          launchCase(scopeTargets, '__', data, stack)\n        },\n      }),\n    ]\n  } else {\n    throwError('expect match to be unit, function or object')\n  }\n  createNode({\n    meta: {op: 'split'},\n    parent: source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {\n      type: 'crosslink',\n      owners: Array.from(owners),\n    },\n    regional: true,\n  })\n  if (!knownCases) return targets\n}\n","import {createDefer} from '../defer'\nimport {is} from '../is'\nimport {launch, forkPage} from '../kernel'\nimport {Scope} from '../unit.h'\n\nexport function allSettled(\n  start: any,\n  {scope, params: ctx}: {scope: Scope; params?: any},\n) {\n  if (!is.unit(start))\n    return Promise.reject(Error('first argument should be unit'))\n  const defer = createDefer()\n  //@ts-ignore\n  defer.parentFork = forkPage\n  const {fxCount} = scope\n  fxCount.scope.defers.push(defer)\n\n  const launchUnits = [start]\n  const launchParams = []\n  if (is.effect(start)) {\n    launchParams.push({\n      params: ctx,\n      req: {\n        rs(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'done', value}\n        },\n        rj(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'fail', value}\n        },\n      },\n    })\n  } else {\n    launchParams.push(ctx)\n  }\n  launchUnits.push(fxCount)\n  launchParams.push(null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    forkPage: scope,\n  })\n  return defer.req\n}\n","import {combine} from './combine'\nimport {createEffect, onSettled} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState, setMeta} from './getter'\nimport {own} from './own'\nimport {is, isFunction} from './is'\nimport {step} from './typedef'\nimport {launch, Stack} from './kernel'\nimport {EFFECT, REG_A} from './tag'\n\nexport function attach(config: any) {\n  let injected\n  onConfigNesting(config, (injectedData, userConfig) => {\n    injected = injectedData\n    config = userConfig\n  })\n  let {source, effect, mapParams} = config\n  const isPlainFunction = !is.effect(effect) && isFunction(effect)\n  if (!mapParams)\n    mapParams =\n      source && !isPlainFunction\n        ? (_: any, source: any) => source\n        : (params: any) => params\n  if (isPlainFunction) {\n    const fn = effect\n    effect = createEffect(([params, state]: [any, any]) => fn(params, state))\n  }\n  const attached = createEffect(config, injected)\n  setMeta(attached, 'attached', true)\n  const {runner} = getGraph(attached).scope\n  let runnerSteps\n  const runnerFn = (\n    {params, req}: any,\n    {finally: anyway, effect, isPlain}: any,\n    stack: Stack,\n  ) => {\n    const rj = onSettled(params, req, false, anyway, stack)\n    let computedParams\n    try {\n      computedParams = mapParams(params, stack.a)\n    } catch (err) {\n      return rj(err)\n    }\n    launch({\n      target: effect,\n      params: {\n        params: isPlain ? [computedParams, stack.a] : computedParams,\n        req: {\n          rs: onSettled(params, req, true, anyway, stack),\n          rj,\n        },\n      },\n      page: stack.page,\n      defer: true,\n    })\n  }\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(source, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    runnerSteps = [\n      /* let another side-effects run first */\n      step.run({fn: _ => _}),\n      /* read state. assumed it already stable here because of previous step */\n      step.mov({\n        store: getStoreState(state),\n        to: REG_A,\n      }),\n      /* no need for step.run because of first step */\n      step.compute({fn: runnerFn}),\n    ]\n  } else {\n    runnerSteps = [step.run({fn: runnerFn})]\n  }\n  own(effect, [attached])\n  runner.scope.effect = effect\n  runner.scope.isPlain = isPlainFunction\n  runner.seq.splice(0, 1, ...runnerSteps)\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import {is} from '../is'\nimport {throwError} from '../throw'\nimport {Domain} from '../unit.h'\nimport {normalizeValues, cloneGraph} from './util'\nimport {getMeta} from '../getter'\n\nexport function fork(\n  domainOrConfig?: Domain | {values?: any; handlers?: any},\n  optiionalConfig?: {values?: any; handlers?: any},\n) {\n  let config: {values?: any; handlers?: any} | void = domainOrConfig as any\n  let domain: Domain\n  if (is.domain(domainOrConfig)) {\n    domain = domainOrConfig\n    config = optiionalConfig\n  }\n\n  const forked = cloneGraph(domain!)\n\n  if (config) {\n    if (config.values) {\n      const valuesSidMap = normalizeValues(\n        config.values,\n        unit =>\n          !is.store(unit) &&\n          throwError('Values map can contain only stores as keys'),\n      )\n      Object.assign(forked.sidValuesMap, valuesSidMap)\n    }\n    if (config.handlers) {\n      forked.handlers = normalizeValues(config.handlers, unit => {\n        if (!is.effect(unit))\n          throwError(`Handlers map can contain only effects as keys`)\n        if (getMeta(unit, 'attached'))\n          throwError('Handlers can`t accept attached effects')\n      })\n    }\n  }\n  return forked\n}\n","import {observableSymbol} from './observable'\nimport {Event} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {assertObject} from './is'\nimport {throwError} from './throw'\nimport {createSubscription} from './subscription'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  if (!observableItem.subscribe)\n    throwError('expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = createSubscription(event)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import {processArgsToConfig} from './config'\nimport {createLinkNode} from './forward'\nimport {sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {assertNodeSet, is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {throwError} from './throw'\nimport {merge} from './merge'\n\nexport function guard(...args: any[]) {\n  const meta: Record<string, any> = {op: 'guard'}\n  let rawName = 'guard'\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (metadata) {\n    meta.config = metadata\n    if (metadata.name) rawName = metadata.name\n  }\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  let {filter, greedy, clock, name = rawName} = config\n  const target = config.target || createEvent(name, meta.config)\n  const filterIsUnit = is.unit(filter)\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'guard', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) source = combine(source)\n  if (clock) {\n    assertNodeSet(clock, 'guard', 'clock')\n    source = sample({\n      source,\n      clock,\n      greedy,\n      fn: filterIsUnit ? null : (source: any, clock: any) => ({source, clock}),\n    })\n  }\n  assertNodeSet(target, 'guard', 'target')\n  if (filterIsUnit) {\n    sample({\n      source: filter,\n      clock: source,\n      target: createNode({\n        node: [\n          step.filter({\n            fn: ({guard}) => guard,\n          }),\n          step.compute({\n            fn: ({data}) => data,\n          }),\n        ],\n        child: target,\n        meta,\n        family: {\n          owners: [source, filter, target, ...[].concat(clock ? clock : [])],\n          links: target,\n        },\n        regional: true,\n      }),\n      fn: (guard: any, data: any) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    if (!isFunction(filter)) throwError('`filter` should be function or unit')\n    createLinkNode(source, target, {\n      scope: {fn: filter},\n      node: clock\n        ? [\n            step.filter({\n              fn: ({source, clock}, {fn}) => fn(source, clock),\n            }),\n            step.compute({\n              fn: ({source}) => source,\n            }),\n          ]\n        : [step.filter({fn: callStack})],\n      meta,\n    })\n  }\n  return target\n}\n","import {is, isObject} from '../is'\nimport {throwError} from '../throw'\nimport {launch} from '../kernel'\nimport type {Domain, Scope} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {forEach, includes} from '../collection'\nimport {STORE} from '../tag'\nimport {normalizeValues} from './util'\nimport {getGraph, getLinks, getMeta, getOwners} from '../getter'\n\nfunction traverse(root: Node, fn: (node: Node, sid: string) => void) {\n  const list = [] as Node[]\n  ;(function visit(node) {\n    if (includes(list, node)) return\n    list.push(node)\n    if (getMeta(node, 'unit') === STORE && getMeta(node, 'sid')) {\n      fn(node, getMeta(node, 'sid'))\n    }\n    forEach(node.next, visit)\n    forEach(getOwners(node), visit)\n    forEach(getLinks(node), visit)\n  })(root)\n}\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain | Scope, {values}: {values: any}) {\n  if (!isObject(values)) {\n    throwError('values property should be an object')\n  }\n  const normalizedValues = normalizeValues(values)\n  const valuesSidList = Object.getOwnPropertyNames(normalizedValues)\n  const storeNodes: Node[] = []\n  const storeValues: any[] = []\n  let forkPage: Scope\n  let traverseTarget: Node\n  if (is.scope(domain)) {\n    forkPage = domain\n    Object.assign(forkPage.sidValuesMap, normalizedValues)\n    if (!forkPage.cloneOf) throwError('scope should be created from domain')\n    traverseTarget = getGraph(forkPage.cloneOf)\n  } else if (is.domain(domain)) {\n    traverseTarget = getGraph(domain)\n  } else {\n    throwError('first argument of hydrate should be domain or scope')\n  }\n  traverse(traverseTarget!, (node, sid) => {\n    // forkPage.sidIdMap[sid] = node.scope.state.id\n    if (includes(valuesSidList, sid)) {\n      storeNodes.push(node)\n      storeValues.push(normalizedValues[sid])\n    }\n  })\n  launch({\n    target: storeNodes,\n    params: storeValues,\n    forkPage: forkPage!,\n  })\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {OPEN_O} from './tag'\nimport {forward} from './forward'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.unit(obj)) {\n    const domain = getParent(obj)\n    let result\n    if (is.event(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        [OPEN_O]: config,\n      }).on(obj, (_, v) => v)\n    }\n    if (is.effect(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        [OPEN_O]: config,\n      })\n      forward({from: obj.doneData, to: result})\n    }\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(obj, (value, key) => {\n    result[key] = is.store(value) ? value : createStore(value, {name: key})\n  })\n  return result\n}\n","import {createDefer} from '../defer'\nimport {is} from '../is'\nimport {throwError} from '../throw'\nimport {launch, forkPage} from '../kernel'\nimport {Scope} from '../unit.h'\n\n/** bind event to scope */\nexport function scopeBind(unit: any, {scope}: {scope?: Scope} = {}) {\n  if (!scope && !forkPage) {\n    throwError('scopeBind cannot be called outside of forked .watch')\n  }\n  const savedForkPage = scope || forkPage!\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: unit,\n          params: {\n            params,\n            req,\n          },\n          forkPage: savedForkPage,\n        })\n        return req.req\n      }\n    : (params: any) => {\n        launch({target: unit, params, forkPage: savedForkPage})\n        return params\n      }\n}\n","import type {Scope, Store} from '../unit.h'\nimport {forIn} from '../collection'\n\n/**\n serialize state on server\n */\nexport function serialize(\n  scope: Scope,\n  {ignore = []}: {ignore?: Array<Store<any>>} = {},\n) {\n  const ignoredStores = ignore.map(({sid}) => sid)\n  const result = {} as Record<string, any>\n  forIn(scope.sidValuesMap, (value, sid) => {\n    if (ignoredStores.includes(sid)) return\n    const id = scope.sidIdMap[sid]\n    // if (!scope.changedStores.has(id)) return\n    if (id && id in scope.reg) {\n      result[sid] = scope.reg[id].current\n    } else {\n      result[sid] = value\n    }\n  })\n  return result\n}\n"],"names":["assertNodeSetItem","value","method","valueName","reason","isObject","isFunction","throwError","assertNodeSet","Array","isArray","i","length","withRegion","unit","cb","regionStack","parent","template","getMeta","readTemplate","sidRoot","getParent","createNode","node","from","source","to","target","child","scope","meta","family","familyRaw","type","regional","sources","arrifyNodes","links","owners","seq","item","push","result","id","nextNodeID","next","CROSSLINK","getOwners","getLinks","own","getValue","forIn","obj","key","forEach","list","fn","launch","payload","upsert","pageForLaunch","currentPage","stackForLaunch","forkPageForLaunch","forkPage","params","defer","page","getForkPage","pushFirstHeapItem","getGraph","isRoot","stop","skip","reg","lastStartedState","isWatch","kernelLoop","deleteMin","idx","stack","hasPageReg","hasScopeReg","local","fail","stepn","step","BARRIER","priority","barrierID","data","fullID","barriers","has","add","pushHeap","delete","STACK","REG_A","VALUE","store","STORE","pageForRef","getPageForRef","initRefInScope","undefined","readRef","getPageRef","current","FILTER","tryRun","EFFECT","fxCount","storeChange","additionalLinks","unitObjectName","objOrArr","name","comma","is","getCompostite","fullName","toString","createName","path","shortName","composite","concat","applyTemplate","args","handlers","createEvent","nameOrConfig","maybeConfig","event","oldPage","setCurrentPage","create","callCreate","graphite","initUnit","EVENT","watch","bind","watchUnit","map","deriveEvent","MAP","callStack","filter","filterMap","defined","prepend","contramapped","createLinkNode","op","applyParentHook","createStore","defaultState","props","onEvent","off","getSubscribers","set","createSubscription","updateStore","updateFilter","plainState","createStateRef","oldState","updates","createNamedEvent","plainStateId","subscribers","Map","stateRef","getState","reachedPage","targetRef","setState","state","reset","units","on","nodeSet","currentSubscription","get","firstState","config","lastResult","console","error","storeState","innerStore","OPEN_O","strict","linkNode","addRefOp","getStoreState","noInit","eventOrFn","subscription","defaultConfig","changed","update","_","a","sid","isStrict","combine","handler","stores","onConfigNesting","injectedData","userConfig","structStoreShape","shapeReady","noArraySpread","rawHandler","slice","storeCombination","createDefer","req","Promise","rs","rj","catch","err","createEffect","instance","getType","setMeta","kind","use","anyway","finally","done","named","status","doneData","failData","effectRunner","getHandler","getCurrent","handlerId","onResolve","onSettled","onReject","then","fx","runner","upd","savedFork","setForkPage","inFlight","x","pending","amount","merge","events","forward","sample","greedy","clock","metadata","processArgsToConfig","atLeastOneFieldExists","sampleConfigFields","field","validateSampleConfig","needToCombine","isUpward","sourceRef","SAMPLER","callARegStack","SAMPLE","hasSource","sourceState","clockState","callStackAReg","normalizeValues","values","assertEach","observableSymbol","Symbol","observable","DOMAIN","SCOPE","effect","domain","message","Error","assertObject","idCount","nextUnitID","nextStepID","cmd","nextBarrierID","barrier","mov","check","compute","run","ref","before","graph","getConfig","opts","getNestedConfig","val","ownerUnit","owner","link","readSidRoot","flat","includes","removeItem","pos","indexOf","splice","heap","b","ret","isSameType","v","r","l","queue","ix","first","last","size","getPriority","bucket","t","Set","newForkPage","newPage","isGetState","refsMap","sidIdMap","sidValuesMap","isFresh","compositeName","rawConfig","injected","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","clearNode","ownerSet","history","effects","domains","unsubscribe","normalizeConfig","part","loc","hookType","hooks","rawConfigA","rawConfigB","isDomain","unitId","thru","subscribe","observer","nativeTemplate","mapped","stateFirst","storeRef","needSpread","clone","stateNew","rawShape","storeStateRef","spread","childRef","defaultShape","ok","sidechain","createHook","trigger","acc","res","hook","launchCase","scopeTargets","start","ctx","reject","parentFork","defers","launchUnits","launchParams","mapParams","isPlainFunction","attached","runnerSteps","runnerFn","isPlain","computedParams","setters","createDomain","onCreateEvent","onCreateEffect","onCreateStore","onCreateDomain","domainOrConfig","optiionalConfig","forked","forkInFlightCounter","fxID","resolve","__","storeStack","storeNode","resultScope","cloneOf","stateGetter","cloneGraph","valuesSidMap","Object","assign","observableItem","disposer","complete","rawName","filterIsUnit","guard","traverseTarget","normalizedValues","valuesSidList","getOwnPropertyNames","storeNodes","storeValues","root","visit","traverse","savedForkPage","ignore","ignoredStores","targets","match","knownCases","cases","matchIsUnit","matchIsFunction","matchIsShape","splitterSeq","caseNames","keys","String","lastValues","needBarrier","updaterSteps","storeOrFn","updater","caseName"],"mappings":"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"}