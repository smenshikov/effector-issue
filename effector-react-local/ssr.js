function e(e){return e&&'object'==typeof e&&'default'in e?e.default:e}function t(e,t,r){let n={node:[effector.step.run({fn:e=>t(e)})]};if(r){let t=effector.createNode(n),o=e.graphite.id,s=r.additionalLinks[o]=r.additionalLinks[o]||[];return s.push(t),()=>{let e=s.indexOf(t);-1!==e&&s.splice(e,1),effector.clearNode(t)}}{n.parent=e,n.family={type:'crosslink',owners:e};let t=effector.createNode(n);return()=>{effector.clearNode(t)}}}function r(e,t){return t.displayName=e,t}function n(e,r){effector.is.store(e)||y('expect useStore argument to be a store');let n=m(e,r),o=k(),s=f.useRef({store:e,value:n,pending:0});return d((()=>{let n=t(e,(e=>{let t=s.current;t.pending||(t.value=e,t.pending=1,o(),t.pending=0)}),r),u=m(e,r),a=s.current;return a.store===e&&a.value!==u&&(a.value=u,a.pending=1,o(),a.pending=0),a.store=e,n}),[e]),n}function o([e,r],n){let o,u,a,l=x;r?(o=r,u=e,a=[]):(o=e.fn,u=e.store,a=e.keys,l=e.updateFilter||x),effector.is.store(u)||y('useStoreMap expects a store'),Array.isArray(a)||y('useStoreMap expects an array as keys'),'function'!=typeof o&&y('useStoreMap expects a function');let i=f.useRef({}),c=i.current;c.fn=o,c.upd=l,c.init=c.store===u,c.store=u;let p=k(),v=f.useMemo((()=>(s(m(u,n),a,i.current),t(u,(e=>s(e,a,i.current,p)),n))),a);return d((()=>()=>v()),a),c.val}function s(e,t,r,n){let o=r.fn(e,t);r.init?void 0!==o&&x(o,r.val)&&r.upd(o,r.val)&&(r.val=o,n&&n()):(r.val=o,r.init=1)}function u(){let e=f.useContext(v);return e||y('No scope found, consider adding <Provider> to app root'),e}function a(e,t={}){let[r,n,o]=c([e.open,e.close,e.set]);((e,t={})=>{let r=f.useRef(null);d((()=>(e.open(r.current),()=>e.close(r.current))),[e]),((e,t)=>{if(e===t)return 1;if('object'==typeof e&&null!==e&&'object'==typeof t&&null!==t){let r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return 0;for(let n=0;n<r.length;n++){let o=r[n];if(e[o]!==t[o])return 0}return 1}return 0})(r.current,t)||(r.current=t,e.set(t))})(f.useMemo((()=>({open:r,close:n,set:o})),[e,r]),t)}function l(e,t){return r(`Connect(${t.displayName||t.name||'Unknown'})`,(r=>f.createElement(t,{...r,...i(e)})))}function i(e){return n(e,u())}function c(e){let t=u(),r=effector.is.unit(e)||'object'!=typeof e?{event:e}:e;return f.useMemo((()=>{if(effector.is.unit(e))return effector.scopeBind(e,{scope:t});let r=Array.isArray(e)?[]:{};for(let n in e)r[n]=effector.scopeBind(e[n],{scope:t});return r}),[t,...Object.keys(r),...Object.values(r)])}Object.defineProperty(exports,'__esModule',{value:1});var p=require('react'),effector=require('effector'),f=e(p);let d='undefined'!=typeof window?f.useLayoutEffect:f.useEffect,y=e=>{throw Error(e)};const m=(e,t)=>t?t.getState(e):e.getState(),x=(e,t)=>e!==t,k=()=>f.useReducer((e=>e+1),0)[1],v=f.createContext(null);let{Provider:g}=v;exports.Provider=g,exports.connect=e=>t=>l(t,e),exports.createComponent=()=>{y('not implemented')},exports.createContextComponent=(e,t,r)=>n=>{let o=f.useContext(t),s=i(e);return r(n,s,o)},exports.createGate=e=>(e&&effector.is.domain(e.domain)||y('config.domain should exists'),(({name:e="gate",domain:t,defaultState:n,hook:o})=>{function s(e){return o(s,e),null}let u=`${t?`${t.compositeName.fullName}/`:''}${e}`,a=effector.createEvent(`${u}.set`),l=effector.createEvent(`${u}.open`),i=effector.createEvent(`${u}.close`),c=effector.createStore(Boolean(0),{name:`${u}.status`}).on(l,(()=>Boolean(1))).on(i,(()=>Boolean(0))),p=effector.createStore(n,{name:`${u}.state`}).on(a,((e,t)=>t)).reset(i);if(t){let{hooks:e}=t;effector.launch({target:[e.store,e.store,e.event,e.event,e.event],params:[c,p,l,i,a]})}return s.open=l,s.close=i,s.status=c,s.state=p,s.set=a,r(`Gate:${u}`,s)})({domain:e.domain,name:e.name,defaultState:'defaultState'in e?e.defaultState:{},hook:a})),exports.createReactState=l,exports.createStoreConsumer=e=>t=>{let r=i(e);return t.children(r)},exports.useEvent=c,exports.useGate=a,exports.useList=(e,t)=>((e,t,s)=>{let u,a,l=[];'object'==typeof t&&null!==t?(t.keys&&(l=t.keys),u=t.fn,t.getKey&&(a=t.getKey)):u=t,effector.is.store(e)||y('expect useList first argument to be a store'),'function'!=typeof u&&y("expect useList's renderItem to be a function"),Array.isArray(l)||y("expect useList's keys to be an array");let i=f.useMemo((()=>{let t=r(`${e.shortName||'Unknown'}.Item`,(t=>{let{index:r,keys:n,keyVal:u,value:a}=t;if(c.current[1])return c.current[0](a,u);let l=o([{store:e,keys:[r,...n],fn:(e,t)=>e[t[0]]}],s);return c.current[0](l,r)}));return f.memo(t)}),[e,!!a]),c=f.useRef([u,a]);c.current=[u,a];let p=f.useMemo((()=>l),l);if(a)return n(e,s).map((e=>{let t=c.current[1](e);return f.createElement(i,{keyVal:t,key:t,keys:p,value:e})}));{let t=o([{store:e,keys:[e],fn:e=>e.length}],s);return Array.from({length:t},((e,t)=>f.createElement(i,{index:t,key:t,keys:p})))}})(e,t,u()),exports.useStore=i,exports.useStoreMap=(e,t)=>{let r=u();return o(t?[e,t]:[{store:e.store,keys:e.keys,fn:e.fn,updateFilter:e.updateFilter}],r)};
//# sourceMappingURL=ssr.js.map
